---
layout: default
---

<div class="grid_10 prefix_1">
	<div class="subheader">
		Networking
	</div>
	<div>
		<p>One of the most useful things ProcessWanker can do is allow you to control
			services that are running on multiple remote machines. With a single command,
			you can perform a rolling-restart on all your Rails servers, check on the
			CPU usage of all your databases, or perform any number of other useful tasks.</p>
		<p>ProcessWanker configuration files are Ruby scripts, so we can do clever things
			on-the-fly - like automatically querying the Amazon AWS SOAP API to enumerate all the
			EC2 boxes that belong to a specific "cluster", rather than hard-coding them
			all into a configuration file.</p>
		<p>For security reasons, ProcessWanker relies on OpenSSL for communications between
			clients and daemons. Setting up a ProcessWanker deployment involves a few steps,
			and at least a minimal understanding of how SSL certificates work. Don't worry
			though - we'll walk you through it!</p>
	</div>
</div>

<div class="grid_10 prefix_1">
	<div class="subheader">
		SSL Certificates - A Primer (you don't <i>really</i> need to know this)
	</div>
	<p>Both clients and daemons use "certificates" to identify themselves to each
		other. A certificate is a file that contains a description of who the owner is,
		plus a cryptographic <i>signature</i> that proves the validity of the certificate.
		It is used a "proof" that the owner is who he/she claims to be.</p>
	<p>The <i>signature</i> is generated by a trusted <i>Certificate Authority</i> (CA).
		This is an entity that everyone (clients and daemons alike) agree to trust.</p>
	<p>All clients and daemons also have a <i>private key</i> which is known only to
		them.</p>
	<p>A <i>Certificate Authority</i> also has a certificate and private key. These two
		items together can be used to create <i>new</i>, <i>signed</i> certificates, for regular
		clients and daemons to use.</p>
	<p>If a daemon and a client both have their own local copies of the CA's certificate,
		they can successfully prove their identities to each other by sending each other
		copies of their own certificates. They also need local copies of their own
		private keys. (Private keys are never shared).</p>
</div>

<div class="grid_10 prefix_1">
	<div class="subheader">
		A walkthrough - creating the Certificate Authority
	</div>
	<p>So, let's walk through a full setup.</p>
	<p>We need to start by making a Certificate Authority. <b>This is typically a one-time step
		that will generate two files:</b></p>
	<ul>
		<li><b>CA Certificate</b>
			<p>This will be deployed alongside every daemon and client. It doesn't need
				to be kept secret.</p>
		</li>
		<li><b>CA private key</b>
			<p>This needs to be kept secure. It is used (along with the CA certificate) to 
				generate and sign client/daemon certificates. If this key is leaked, other
				people could forge their own certificates that could potentially be used to
				control services on your servers.</p>
		</li>
	</ul>
	<p>To generate the CA files, we do this:</p>
</div>

<div class="grid_8 prefix_2">
<pre class="prettyprint">
$ pw --generate-ca --output-prefix ./ca
</pre>
</div>

<div class="grid_10 prefix_1">
	<p>This will generate the two files we're after: <code>ca.crt</code> and <code>ca.key</code>.
</div>

<div class="grid_10 prefix_1">
	<div class="subheader">
		A walkthrough - creating the user certificate(s) and key(s)
	</div>
	<p>At this point, we have a few choices.</p>
	<ul>
		<li><b>One certificate/key for all!</b>
			<p>We can make one certificate and private key, and share them between all
				clients and daemons in our system. This has the advantage of being simpler.
				Because we're using our own CA, we can be sure that nobody outside our
				organization can control our services.</p>
			<p>It has the disadvantage, however, that it's hard for us to revoke a certificate.
				If one of our clients goes rogue, or has his/her laptop stolen, it's possible
				that an attacker could control our services. We would need to regenerate a new 
				certificate and key - and replace the old ones <i>everywhere</i>.</p>
		</li>
		<li><b>One certificate/key for daemons, clients each have their own</b>
			<p>It's far more important for us to be sure that the <i>clients</i> are
				who they say they are. It's not really that big of a security hole if
				somebody is able to impersonate one of our daemons - the most they would
				be able to do is see which processes we were trying to stop/start!</p>
			<p>This is a good compromise. Since each client has their own certificate,
				it is possible for daemons to identify them individually. We can therefore
				control which clients are allowed access, and reject requests from clients
				whose certificate/key have been lost.</p>
		</li>
		<li><b>Every daemon and client has their own certificate/key</b>
			<p>This is completely doable, but probably overkill</p>
		</li>
	</ul>
	<p>We'll go with the second option for now. Let's create the certificate and key that the
		daemons will use:</p>
</div>

<div class="grid_8 prefix_2">
<pre class="prettyprint">
$ pw --generate-client daemons --ca-prefix ./ca --output-prefix ./daemons
</pre>
</div>

<div class="grid_10 prefix_1">
	<p>As in the previous stage, two files will be generated. In this case:
		<code>daemons.crt</code> and <code>daemons.key</code>. These must be deployed
		on each of the servers that we wish to control, along with the CA certificate.</p>
	<p>We now need to reference these files from the daemon's configuration. We do this
		by adding an auth block - for instance:</p>
</div>

<div class="grid_8 prefix_2">
<pre class="prettyprint">
daemon {

	auth {
		ca_cert         "/etc/pw/certs/ca.crt"
		my_cert         "/etc/pw/certs/daemons.crt"
		my_key          "/etc/pw/certs/daemons.key"
	}
	
	services {
		process_service("blah") {
			...
		}
	}
}
</pre>
</div>

<div class="grid_10 prefix_1">
	<p>Now, let's create a user certificate and key for one of our clients. If you're
		the only person in your organization that needs to be able to control services,
		then this will suffice.</p>
	<p>I'm going to assume your name is Ben:</p>
</div>
<div class="grid_8 prefix_2">
<pre class="prettyprint">
$ pw --generate-client ben --ca-prefix ./ca --output-prefix ./ben
</pre>
</div>
	
<div class="grid_10 prefix_1">
	<p>As one might expect, <code>ben.crt</code> and <code>ben.key</code> will have
		been generated. These should be installed on your local machine, and the client
		block of your configuration file should contain an auth block just like the
		one we set up on the servers.</p>
</div>

<div class="grid_8 prefix_2">
<pre class="prettyprint">
client {

	auth {
		ca_cert         "/etc/pw/certs/ca.crt"
		my_cert         "/etc/pw/certs/ben.crt"
		my_key          "/etc/pw/certs/ben.key"
	}

	...
}
</pre>
</div>

<div class="grid_10 prefix_1">
	<p>The <code>auth</code> block can be placed in a number of different places. It can
		be placed inside a <code>host</code> block, or in any of the blocks that contain the host,
		right up to the root level of the config - in which case it will be the default for both
		client and daemon. As you might expect, if an <code>auth</code> block is found at a more nested level,
		it will override the default.</p>
</div>
