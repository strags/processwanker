---
layout: default
title: Advanced - 
---

<div class="grid_10 prefix_1">
	<div class="subheader">
		More Advanced
	</div>
	<div>
		Let's analyze the previous "Getting Started" example a little bit.
	</div>
</div>
<div class="grid_8 prefix_2">
<pre class="prettyprint">
ProcessWanker::config {
	daemon {
		services {
			process_service("mysql") {
				start_cmd  "/etc/init.d/mysql start"
			}
		}
	}
}		
</pre>
</div>

<div class="grid_10 prefix_1">
	<div>
		A ProcessWanker configuration file contains two "root" sections: <code>client</code>
			and <code>daemon</code>. As previously discussed in "Getting Started", these are the
			two "halves" of ProcessWanker. The daemon runs in the background, monitoring and
			controlling services, and the client is what we run from the command-line to
			control the daemon.
	</div>
</div>

<div class="grid_10 prefix_1">
	<div class="subheader">
		The Daemon Configuration
	</div>
</div>
			
<div class="grid_10 prefix_1">
	<div>
		<p>The daemon configuration block must specify a number of things:</p>
		<ul>
			<li>List of services</li>
			<li>Network interface and port to listen on</li>
			<li>SSL certificate definitions for remote control</li>
		</ul>
		<p>We'll deal with the last two items in the Networking section. For now, let's
			concentrate on how to define services.</p>
	</div>
</div>

<div class="grid_8 prefix_2">
<pre class="prettyprint">
process_service("<code>service-name</code>") {
	<code>...</code>
}
</pre>
</div>

<div class="grid_10 prefix_1">
	<div class="header">
		The <b>process_service</b> class
	</div>
</div>

<div class="grid_10 prefix_1">
	<div>
		<p>ProcessWanker supports a few different mechanisms by which services are started/stopped
			and tracked. Each of these corresponds to a <i>class</i> of service.
		<p>A <code>process_service</code> is an example of one of these classes.
			It's a service that is comprised of one (or more) unix processes. It can
			be launched by <code>exec</code>'ing the given start command.</p>
		<div class="notes">
			<p>process_services are tracked by inserting a "magic cookie" into the parent process's
			<i>environment</i>. Since unix child processes inherit their parent's environment,
			we can use this cookie to match any running processes back to the service (if any)
			that spawned them. We can send KILL or TERM signals to terminate them, without
			having to rely on a PID file, or other mechanism. This works, even if the process
			forks, spawns multiple workers, etc...</p>
		</div>
		<p>A <b>process_service</b> accepts the following parameters:</p>
		<ul>
			<li><code>start_cmd</code>
				<p>The process or script to launch, plus arguments</p>
			</li>
			<li><code>stop_cmd</code> (optional)
				<p>A command for stopping the service. If not provided, the aforementioned
					environment-cookie method will be used to track the service, and a combination
					of SIGTERM/SIGKILL will be used to terminate the relevant process(es).</p>
			</li>
			<li><code>start_dir</code> (optional, default=<code>/</code>)
				<p>The directory in which to launch the service</p>
			</li>
			<li><code>run_user</code> (optional, default=<code>root</code> or pw daemon user)
				<p>A username (string) or UID (integer) defining the user that the service
					should <code>su</code> to before running.</p>
			</li>
			<li><code>soft_kill_limit</code> (optional, default=<code>3</code>)
				<p>When no <code>stop_cmd</code> is provided, ProcessWanker will attempt to
					terminate the service by sending SIGTERM to all of its processes. If the
					service fails to respond after <code>soft_kill_limit</code> attempts,
					ProcessWanker will attempt to kill it using SIGKILL.</p>
			</li>
		</ul>
		</p>
	</div>
</div>

<div class="grid_10 prefix_1">
	<div class="header">
		Common service parameters
	</div>
</div>

<div class="grid_10 prefix_1">
	<div>
		<p>All service classes accept the following <b>optional</b> parameters:</p>
		<ul>
			<li><code>tags</code>
				<p>Optional string tag(s) to assign to the service. These can be used by the
					client to selectively control a group of services. Eg:</p>
				<div>
					<pre class="prettyprint">
tags	"db","pants"
					</pre>
				</div>
			</li>
			<li><code>min_action_delay_secs</code> (default 1)
				<p>Minimum number of seconds to delay between attempts to perform a start or
					stop operation on a service.</p>
			</li>
			<li><code>start_grace_secs</code> (default 5)
				<p>Minimum number of seconds to delay between attempts to start the service.</p>
			</li>
			<li><code>stop_grace_secs</code> (default 5)
				<p>Minimum number of seconds to delay between attempts to stop the service.</p>
			</li>
			<li><code>stable_secs</code> (default 20)
				<p>Minimum number of seconds the service must be "up" for in order to be
				 considered <i>stable</i>.</p>
			</li>
			<li><code>fail_trigger_count</code> (default 5)
				<p>Number of repeated attempts to stop/start a service without it becoming
					stable, before it is considered to be "failing".</p>
			</li>
			<li><code>fail_suppress_secs</code> (default 300)
				<p>Number of seconds to wait before re-attempting to control a "failing"
					service.</p>
			</li>
			<li><code>depends</code>
				<p>Another service (on the same machine) that this service <i>depends</i> on.</p>
				<p>A service will be prevented from launching (and will be stopped if it is
					currently running), as long as any one of its dependencies is not "up".</p>
				<div>
					<pre class="prettyprint">
depends {
   service  "mysql"
   up_for   5
}
					</pre>
				</div>
				<div>
				<p>The <code>service</code> field can be a simple service name, or a full service-spec (see the client command-line reference).</p>
				<p>The <code>up_for</code> defines how many seconds the named service(s) must
					be "up" (ie. running) for before this service is allowed to start.</p>
				</div>
			</li>
			<li><code>logfile</code> (default <code>/dev/null</code>)
				<p>A file to write <code>stdout</code> and <code>stderr</code> to. This is
					independent of any built-in logging mechanism that the launched application
					itself may employ.</p>
			</li>
		</ul>
	</div>
</div>

<div class="grid_10 prefix_1">
	<div class="header">
		The <b>pid_service</b> class
	</div>
</div>

<div class="grid_10 prefix_1">
	<div>
		<div class="notes">
			<p>pid_services are tracked by relying on the launched service to write its
				process-id into a well-known file.</p>
			<p>They behave similarly to the process_service, but are not tracked using the
				environment cookie. Instead, KILL/TERM signals are sent to the process whose
				PID is contained in the named file. If the file is not present, or there is no
				matching process, the service is assumed not to be running.</p>
		</div>
		<p>The pid_service class accepts all the same parameters as the process_service,
			plus one additional:
		<ul>
			<li><code>pid_file</code>
				<p>The file to look inside in order to determine the service's process-id.</p>
			</li>
		</ul>
	</div>
</div>

<!--
<div class="grid_1 button">Hello</div>
<div class="grid_12 button">Hello</div>
-->


<div class="grid_10 prefix_1">
	<div class="subheader">
		The Client Configuration
	</div>
</div>

<div class="grid_10 prefix_1">
	<div>
		<p>The previous "Getting Started" example didn't include a client configuration,
			for the simple reason that when the daemon and client both run on 
			<code>localhost</code>, the default settings are adequate, and no extra configuration
			is necessary.
		</p>
		<p>The only information that needs to be placed in the client block relates to a list
			of remote clusters and hosts that the client is able to control. We'll deal with this
			in the "Networking" section, since it's a fairly large subject in itself.
		</p>
		<p>Here, however, for reference is what the default client configuration block looks like:
		</p>
			
	</div>
</div>
<div class="grid_8 prefix_2">
<pre class="prettyprint">
client {
	clusters {
		cluster("default") {
			host("localhost") {
			}
		}
	}
}
</pre>
</div>
